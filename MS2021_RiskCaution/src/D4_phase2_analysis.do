* Estimate models using Phase 2 data
* Create Table 6

* Set number of reps for GMNL. For debugging, set very low (<10) for speed. For
* real estimation, set in the hundreds (500 recommended).
local n_reps = 500
use "$data/project_choice_all.dta", clear
eststo clear
* Comparing results across all arms and choice scenarios (appendix table)
// eststo mod_base: clogit choice c.attr_mean_n c.attr_variance_n if experiment == 1 & base_sample==1, group(group) vce(cluster id)
// eststo mod_new: clogit choice c.attr_mean_n c.attr_variance_n if experiment == 2 & base_sample==1, group(group) vce(cluster id)
// eststo mod_new1: clogit choice c.attr_mean_n c.attr_variance_n if experiment == 2 & arm==1 & base_sample==1, group(group) vce(cluster id)
// eststo mod_new2: clogit choice c.attr_mean_n c.attr_variance_n if experiment == 2 & arm==2 & base_sample==1, group(group) vce(cluster id)
// eststo mod_new3: clogit choice c.attr_mean_n c.attr_variance_n if experiment == 2 & arm==3 & base_sample==1, group(group) vce(cluster id)
// esttab mod_base mod_new mod_new1 mod_new2 mod_new3 using "a0_comparison_with_baseline.csv", b(2) se(2) pr2(3) star(* 0.10 ** 0.05 *** 0.01) nocons nogaps nonotes replace

** Compare performance across the three arms with nested models
* Table 5
drop if experiment == 1
gen attr_mean_n_arm2 = attr_mean_n*(arm==2)
gen attr_mean_n_arm3 = attr_mean_n*(arm==3)
gen attr_variance_n_arm2 = attr_variance_n*(arm==2)
gen attr_variance_n_arm3 = attr_variance_n*(arm==3)
label var attr_mean_n_arm2 "Mean x Arm 2"
label var attr_mean_n_arm3 "Mean x Arm 3"
label var attr_variance_n_arm2 "Variance x Arm 2"
label var attr_variance_n_arm3 "Variance x Arm 3"
* GMNL 
eststo mod_arm: gmnl choice if base_sample==1 & question == 1, id(id) group(group) rand(attr_mean_n attr_variance_n attr_mean_n_arm2 attr_mean_n_arm3 attr_variance_n_arm2 attr_variance_n_arm3) vce(cluster id) gamma(1) seed(1012) nrep(`n_reps')
* The predictions generated by these are the same.
gmnl_margin if question==1 & base_sample==1, generate(pred_set1arm2comp) het(arm2)
gmnl_margin if question==1 & base_sample==1, generate(pred_set1arm3comp) het(arm3)
* Clogit
eststo mod_arm_cl: clogit choice attr_mean_n attr_variance_n  attr_mean_n_arm2 attr_mean_n_arm3 attr_variance_n_arm2 attr_variance_n_arm3 if question == 1 & base_sample ==1, group(group) vce(cluster id)
esttab mod_arm mod_arm_cl using "Table5_a1_treatment_arm_gmnl_cl.csv", b(2) se(2) pr2(3) star(* 0.10 ** 0.05 *** 0.01) nocons nogaps nonotes replace

* Plot of coefficients from different arms: same info as above estimates, just in marginal effects form
// capture drop vv_*
// gen attr_variance_one = attr_variance*(arm==1)
// gen attr_variance_two = attr_variance*(arm==2)
// gen attr_variance_three = attr_variance*(arm==3)
// label var attr_variance_one "Replication"
// label var attr_variance_two "No loss framing"
// label var attr_variance_three "Objective returns"
// reg pred_set1arm2comp attr_mean attr_variance_*, cluster(id)
// estimates store mar_treat
// * Put this way, you can see that there is a difference bewteen arms 1 and 2 (and therefore between arms 2 and 3)
// reg pred_set1arm2comp attr_mean attr_variance attr_variance_two attr_variance_three, r
// * Compare to conditional logit (the estimates are a bit different, but not by much)
// *clogit choice attr_mean_n attr_variance_n v_arm2 v_arm3 if base_sample==1 & question == 1, group(group) vce(cluster id)
// coefplot (mar_treat, ciopts(lcolor(black)) color(black)), ///
//        keep(attr_variance_*)  byopts(row(1)) ///
//        graphregion(margin(l=50)) coeflabels(, notick labgap(-125)) ///
//        xline(0, lcolor(black)) ///
//        headings(vattr_variance_n_one = "{bf:Phase 2 Experiments}" ///
//        , labgap(-130)) ///
//        xscale(r(0.05, -0.1)) xlabel(-0.1(0.05)0.05) ///
//        yscale(noline alt) legend(off) scale(1.1) levels(99)
// graph export "project_choice_1_arm1_3.pdf", replace as(pdf)
// graph export "project_choice_1_arm1_3.png", replace as(png)
//
// *** Loss aversion 
// capture drop attr_mean_n_* attr_variance_n_*
// foreach v of varlist loss_alpha loss_beta loss_lambda {
//    gen attr_mean_n_`v' = attr_mean_n*`v'
//    gen attr_variance_n_`v' = attr_variance_n*`v'
// }
// * Estimation
// eststo mod_loss1_cl: clogit choice attr_mean_n attr_variance_n attr_mean_n_* attr_variance_n_* if base_sample==1 & question == 1 & arm==1, group(group) vce(cluster id)
// eststo mod_loss1: gmnl choice if base_sample==1 & question==1 & arm == 1, id(id) group(group) rand(attr_mean_n attr_variance_n attr_mean_n_* attr_variance_n_*) vce(cluster id) gamma(1) nrep(`n_reps')
// gmnl_margin if question==1 & base_sample==1, generate(pred_set1lambda) het(loss_beta)
// esttab mod_loss1 mod_loss1_cl using "a1_loss_aversion_lambda_gmnl_cl.csv", b(2) se(2) pr2(3) star(* 0.10 ** 0.05 *** 0.01) nocons nogaps nonotes replace

// log close
* EOF


